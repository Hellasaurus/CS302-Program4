
# gathering.py
# Daniel Melancon
# CS 302 - 001
# Project 4/5
# main hierarchy for Magic the gathering collection tracker


import json

class Card:
    '''Class that contains card information.'''

    def __init__(self, name, type):
        self._name_:str = name
        self._type_ = type

    def display(self):
        print("Name: " + self._name_)
        print("Types: " + str(self._type_))
        pass

    def __eq__(self, __value: object) -> bool:
        if type(__value) == Card:
            return self._name_ == __value._name_
        return str(__value) == self._name_

    def getName(self)->str:
        '''gets the card's name - used for making lists'''
        return self._name_

    def isCounted(self) -> bool: 
        '''Returns true if the card can only have a limited number of copies. used for determining legality'''
        return 'Land' not in self._type_
    
    def __str__(self) -> str:
        return self._name_ + " "+ str(self._type_)

class CardGenerator:
    '''# Card Generator
    uses a json file containing information on magic the gathering cards to create cards. 
    
    ### Source:
    https://mtgjson.com/'''

    def __init__(self, path = "StandardAtomic.json") -> None:

        Standard_path = path

        file = open(Standard_path, 'r', encoding='utf8')

        Standard_data = json.load(file)

        self._cardList_ = Standard_data['data']
        
        self._cache_ = {}
        self._failedToFind_ = []
        pass

    def getCard(self, name:str) -> object:
        '''Creates an instance of the card, storing generated cards in self.cards to avoid redundant queries
        ### Param: 
        name: the name of a magic the gathering card
        ### Return:
        A card object with the appropriate attributes'''
        if name in self._cache_.keys(): return self._cache_[name]
        else: 
            try:
                myCard = Card(name, self._cardList_[name][0]['types'])
                self._cache_[name] = myCard
            except:
                self._failedToFind_.append(name)
                return None
        return myCard
    
    def getFailures(self) -> list:
        '''Gets the list of failed queries'''
        return self._failedToFind_
    
    def getCache(self) -> dict:
        '''Gets the cache, a dict containing all the cards generated by this object.'''
        return self._cache_



FORMATS = ["Commander", "Standard", "Limited"]

MAX_COUNT = {
    "Standard" : 4 , 
    "Commander": 1 ,
    "Limited"  : None
}

MIN_LEGAL_SIZE = {
    "Standard" : 60 ,
    "Commander": 99 ,
    "Limited"  : 40
}

MAX_LEGAL_SIZE = {
    "Standard" : None ,
    "Commander": 99 ,
    "Limited"  : None
}


class Collection:
    '''A structure that associates cards'''

    def __init__(self):
        self._cards_ = [] 

    def getCards(self):
        '''Fetches the list containing the collection's cards'''
        return self._cards_
    
    def __iadd__(self, card:Card):
        self.addCard(card)
        return self
    
    def __isub__(self, card:Card):
        self._cards_.remove(card)
        return self

    def addCard(self, card):
        '''Add a card to the collection'''
        if type(card) is Card:
            self._cards_.append(card)
    
    def remove(self, card):
        '''Reomve a card from the collection'''
        for i, c in enumerate(self._cards_):
            if c == card:
                self._cards_.pop(i)
                return True
        return False


    def has(self, card) -> bool:
        '''check if a card is in the collection'''
        return (card in self._cards_)
    
    def __str__(self) -> str:
        return str([str(i) for i in self._cards_])
    

class Deck (Collection):
    '''A species of Collection that enforces deckbuilding rules'''

    def __init__(self, name:str = "New Deck", format = "Standard"):
        self._name_:str = name
        self._format_:str = format

        self._maxCount_ = MAX_COUNT[format]
        self._minLegalSize_ = MIN_LEGAL_SIZE[format]
        self._maxLegalSize_ = MAX_LEGAL_SIZE[format]
        super().__init__()
    
    def __lt__(self, deck) -> bool: 
        return self._name_ < deck.name
    def __eq__(self, deck) -> bool:
        return self._name_ == deck.name

    def isLegal(self) -> bool:

        '''checks if the deck follows all deckbuilding requirements'''
        if not (self._minLegalSize_ < len(self._cards_) < self._maxLegalSize_):
            return False
            
        if max( self._cards_ , key=list.count) > self._maxCount_:
            return False
        
    def addCard(self, card):
        '''Checks:
        ## Returns:
        True if card was added, else False'''
        # TODO: Add logic to restrict card count
        if type(card) != Card: return False

        self._cards_.append(card)
        return True
    
    def __str__(self) -> str:
        '''returns the list of cards preceded by the name of the deck'''
        return self._name_ + ' :\nFormat :' + self._format_ + '\n' + super().__str__()
        
class CommanderDeck(Deck):
    '''A commander deck follows the following construction rules:
    * There is a special card called the commander that follows additional rules
    * Decks must be exactly 99 cards and can have no duplicate spellse
    * Decks must be within the identity of the commander'''
    def __init__(self, name = "New Commander Deck"):
        self._Commander_:Card = None
        self._identity_ = None

        super().__init__()
    
    def isLegal(self) -> bool:
        if not super().isLegal():
            return False
        # TODO commander identity check

    def setCommander(self, card:Card):
        if self.has(card): 
            pass
        self._Commander_ = card

    def __str__(self) -> str:
        return self._name_ + '\nCommander: ' + str(self._Commander_) + '\n' + Collection.__str__()